# -*- coding: utf-8 -*-
"""EngineDynamometer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xXW-lpPY6unzWLIvj34yn0SoHZhPomZg
"""

import math
import matplotlib.pyplot as plt
import numpy as np
import random

# Constants
MASS = 0.2  # kg
RADIUS = 0.1  # meters
MAX_RPM = 7000
CONST = float((2*math.pi)/60)

# Generate RPM points from 0 to 7000 in steps of 100
rpm_points = np.arange(0, MAX_RPM + 100, 100)

# Generate time intervals with a physics-based approach
def generate_time_intervals(rpm_points):
    intervals = []

    # Base parameters for time calculation
    base_interval = 0.05  # Base time interval in seconds
    inertia_factor = 0.00001  # Factor to simulate rotational inertia
    noise_factor = 0.05  # 5% maximum noise

    for i in range(len(rpm_points)-1):
        rpm_change = rpm_points[i+1] - rpm_points[i]

        # More time needed for higher RPM changes due to inertia
        physics_time = base_interval + (rpm_change * inertia_factor)

        # Add progressive resistance at higher RPMs
        rpm_resistance = (rpm_points[i] / MAX_RPM) * 0.02
        physics_time *= (1 + rpm_resistance)

        # Add small controlled noise
        noise = random.uniform(-noise_factor, noise_factor) * physics_time
        interval = physics_time + noise

        intervals.append(max(0.02, interval))  # Ensure minimum interval

    return intervals

time_intervals = generate_time_intervals(rpm_points)

def calculate_torque(rpm):
    max_torque = 0.5
    decay_factor = 2000
    base_torque = max_torque * (decay_factor / (rpm + decay_factor/2))
    # Add smaller, more controlled noise to torque
    noise = random.uniform(-0.01, 0.01)  # Reduced random variation
    return base_torque + noise

# Calculate torques and powers with added noise
torques = []
powers = []

for rpm in rpm_points:
    # Calculate torque with noise
    torque = calculate_torque(rpm)
    torques.append(torque)

    # Calculate power with more controlled noise
    power_factor = -((rpm - 4000) ** 2) / (2000 ** 2)
    base_power = torque * (rpm * CONST) * math.exp(power_factor)
    power_noise = random.uniform(-0.03, 0.03) * base_power  # Reduced proportional noise
    powers.append(base_power + power_noise)

# Create figure with two subplots
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), dpi=120)

# Plot torque
ax1.plot(rpm_points, torques, 'r-', label='Torque (Nm)', linewidth=1.5, marker='o', markersize=2)
ax1.set_xlabel('RPM')
ax1.set_ylabel('Torque (Nm)', color='r')
ax1.tick_params(axis='y', labelcolor='r')
ax1.grid(True, alpha=0.3)
ax1.legend()

# Plot power
ax2.plot(rpm_points, powers, 'b-', label='Power (W)', linewidth=1.5, marker='o', markersize=2)
ax2.set_xlabel('RPM')
ax2.set_ylabel('Power (W)', color='b')
ax2.tick_params(axis='y', labelcolor='b')
ax2.grid(True, alpha=0.3)
ax2.legend()

# Add main title
plt.suptitle('Lego Vacuum Engine Performance Curves', fontsize=14, y=0.95)

plt.tight_layout()
plt.show()

# Print some key statistics
max_torque = max(torques)
max_power = max(powers)
max_torque_rpm = rpm_points[torques.index(max_torque)]
max_power_rpm = rpm_points[powers.index(max_power)]

print(f"\nPerformance Statistics:")
print(f"Maximum Torque: {max_torque:.2f} Nm at {max_torque_rpm} RPM")
print(f"Maximum Power: {max_power:.2f} W at {max_power_rpm} RPM")

import math
import matplotlib.pyplot as plt
import numpy as np
import librosa
import scipy.signal
from scipy.io import wavfile
from scipy.fft import fft, fftfreq
from google.colab import drive

drive.mount('/content/drive')

class DynoAnalyzer:
    def __init__(self):
        self.mass = 0.0
        self.radius = 0.0
        self.const = float((2*math.pi)/60)
        self.rpm_calibration = {}  # Store RPM-to-frequency calibration

    def input_initial_data(self):
        self.mass = float(input("Mass of inertia dyno (Kg): "))
        self.radius = float(input("Radius of inertia dyno (meters): "))

    def calibrate_rpm_frequencies(self, calibration_files):
        """
        Calibrate RPM detection using reference audio files
        calibration_files: dict of {rpm: filepath} for reference sounds
        """
        for rpm, filepath in calibration_files.items():
            # Load audio file
            y, sr = librosa.load(filepath)

            # Get dominant frequency using FFT
            frequencies = self._get_dominant_frequencies(y, sr)

            # Store the mapping of frequency to RPM
            self.rpm_calibration[rpm] = np.mean(frequencies)

        # Create interpolation function for RPM estimation
        rpms = list(self.rpm_calibration.keys())
        freqs = list(self.rpm_calibration.values())
        self.rpm_interpolator = np.poly1d(np.polyfit(freqs, rpms, 2))

    def _get_dominant_frequencies(self, audio_data, sample_rate, window_size=2048):
        """Extract dominant frequencies from audio data"""
        frequencies = []

        # Process audio in windows
        for i in range(0, len(audio_data), window_size):
            window = audio_data[i:i+window_size]
            if len(window) == window_size:
                # Compute FFT
                fft_data = fft(window)
                freqs = fftfreq(window_size, 1/sample_rate)

                # Get magnitude spectrum
                magnitude = np.abs(fft_data)

                # Find dominant frequency (exclude very low frequencies)
                valid_idx = (freqs > 20) & (freqs < 1000)
                max_idx = np.argmax(magnitude[valid_idx])
                dominant_freq = abs(freqs[valid_idx][max_idx])

                frequencies.append(dominant_freq)

        return frequencies

    def high_pass_filter(self, audio_data, sample_rate, cutoff=20, order=5):
        """Apply a high-pass filter to remove wind noise"""
        nyquist = 0.5 * sample_rate
        normal_cutoff = cutoff / nyquist
        b, a = scipy.signal.butter(order, normal_cutoff, btype='high', analog=False)
        return scipy.signal.filtfilt(b, a, audio_data)

    def smooth_frequencies(self, frequencies, window_size=5):
        """Apply smoothing to frequency data"""
        return np.convolve(frequencies, np.ones(window_size)/window_size, mode='valid')

    def analyze_dyno_pull(self, audio_file):
        """Analyze a complete dyno pull audio file"""
        # Load audio
        y, sr = librosa.load(audio_file)

        # Apply high-pass filter to reduce wind noise
        y_filtered = self.high_pass_filter(y, sr)

        # Get frequencies over time
        frequencies = self._get_dominant_frequencies(y_filtered, sr)

        # Smooth frequencies to reduce noise
        frequencies = self.smooth_frequencies(frequencies)

        # Convert frequencies to RPM using calibration
        rpms = [self.rpm_interpolator(f) for f in frequencies]

        # Calculate time points
        times = np.linspace(0, len(y_filtered)/sr, len(rpms))

        # Calculate acceleration and torque
        torques = []
        powers = []
        for i in range(1, len(rpms)):
            delta_rpm = rpms[i] - rpms[i-1]
            delta_t = times[i] - times[i-1]

            if delta_t > 0.01:  # Prevent small delta_t from exaggerating torque
                torque = self._calculate_torque(delta_rpm, delta_t)
                power = self._calculate_power(torque, rpms[i])
                torques.append(torque)
                powers.append(power)

        return rpms[1:], torques, powers, times[1:]

    def _calculate_torque(self, delta_rpm, time):
        """Calculate torque given RPM change and time"""
        # Convert RPM to angular velocity (rad/s) first
        delta_omega = (delta_rpm * self.const)  # Change in angular velocity
        angular_acceleration = delta_omega / time  # Angular acceleration in rad/sÂ²
        moment_of_inertia = 0.5 * self.mass * math.pow(self.radius, 2)
        torque = moment_of_inertia * angular_acceleration
        return torque

    def _calculate_power(self, torque, rpm):
        """Calculate power in watts"""
        return torque * rpm * self.const

    def plot_results(self, rpms, torques, powers, times):
        """Plot RPM, torque, and power curves"""
        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))

        # RPM vs Time
        ax1.plot(times, rpms)
        ax1.set_xlabel('Time (s)')
        ax1.set_ylabel('RPM')
        ax1.set_title('RPM vs Time')

        # Torque vs RPM
        ax2.plot(rpms, torques)
        ax2.set_xlabel('RPM')
        ax2.set_ylabel('Torque (Nm)')
        ax2.set_title('Torque vs RPM')

        # Power vs RPM
        ax3.plot(rpms, powers)
        ax3.set_xlabel('RPM')
        ax3.set_ylabel('Power (W)')
        ax3.set_title('Power vs RPM')

        plt.tight_layout()
        plt.show()


def main():
    # Initialize DynoAnalyzer
    analyzer = DynoAnalyzer()

    # Input the initial data (mass, radius)
    analyzer.input_initial_data()

    # Ask for maximum RPM (you already know the RPM values, so let's use 1000 to 7000 RPM in steps of 1000)
    rpms = list(range(1000, 8000, 1000))  # RPMs from 1000 to 7000 at 1000 RPM intervals

    # Set file paths for calibration files in Google Drive
    print("Using calibration files stored in Google Drive.")
    calibration_files = {}
    for rpm in rpms:
        file_path = f"/content/drive/MyDrive/DynoData/{rpm}rpm.wav"  # Adjusted path to V2/Converted folder
        calibration_files[rpm] = file_path  # Store the file path for each RPM

    # Calibrate RPM frequencies
    analyzer.calibrate_rpm_frequencies(calibration_files)
    print("Calibration Complete")

    # Specify the dyno pull file path in Google Drive
    dyno_file = "/content/drive/MyDrive/DynoData/DynoPull.wav"  # Adjusted path to DynoPull.wav file

    # Analyze dyno pull
    rpms, torques, powers, times = analyzer.analyze_dyno_pull(dyno_file)

    # Plot results
    analyzer.plot_results(rpms, torques, powers, times)

if __name__ == "__main__":
    main()